#  -*- Autoconf -*-
#
# the monotone integration testsuite is written in bourne shell,
# strung together with the autotest framework (part of autoconf).
#
# it's a bit icky but it's better than the hand-written thing we were
# using before, and it's *certainly* more user friendly than dejagnu, 
# and we need *some* tests which run "as the user would run them".
# bourne shell scripts are pretty close to that.
#

AT_INIT([integration tests])
AT_TESTED([monotone])

# some command abbreviations to make life easier

# Set PREEXECUTE in your environment to run monotone under, e.g., valgrind.
m4_define([MONOTONE], [$PREEXECUTE $_MT_EXEC --rcfile=$_ROOT_DIR/test_hooks.lua --nostd --norc --db=$_ROOT_DIR/test.db --key=tester@test.net --root=$_ROOT_DIR])
m4_define([RAW_MONOTONE], [$PREEXECUTE monotone --norc])
m4_define([SHA1], [monotone --norc identify $1])
m4_define([BASE_REVISION], [cat MT/revision])
m4_define([WORKING_REVISION], [monotone --norc cat revision | monotone --norc identify])
m4_define([CANONICALISE], [
if test "$OSTYPE" == "msys"; then
  dos2unix -q -o $1
fi
])

# the MONOTONE_SETUP macro deploys the standard lua hooks and loads the 
# standard testing key, which we use for further tests.

m4_define([MONOTONE_SETUP], [

# Absolutify monotone path
_MT_EXEC=`which monotone`

# Save the PWD so MONOTONE macro can refer back to it
_ROOT_DIR=`pwd -P`

AT_DATA(test_keys, [@<:@pubkey tester@test.net@:>@
MIGdMA0GCSqGSIb3DQEBAQUAA4GLADCBhwKBgQCfN/cAMabgb6T7m8ksGnpQ7LO6hOdnc/7V
yivrRGtmpwSItljht1bmgLQF37KiSPoMEDUb1stfKxaMsYiy8iTyoQ+M2EVFP37n2rtnNZ0H
oVcQd2sRsCerQFh9nslRPymlkQXUlOiNFN6RlFNcdjkucqNe+YorFX21EYw7XuT5XwIBEQ==
@<:@end@:>@
@<:@privkey tester@test.net@:>@
npy0jyqbZdylFkMjdR9OvlqmDHuBGXpGFPt94h96aG+Lp+OdBCmWx8GueHk8FKkexwPqhRBM
PPopUeuwqxuSX+yEodMl5IHBmin0nLnbOeBjtasjemBFEmdNl/jPDF/AeQ2WHhanB731dSQc
vzLOQfKAYmfk56PPULi9oJJNUxaCkvsWtvaI+HUHZrjyyV7dA4Vsc6Jvx2Yf1+MdDAEGk/Rw
ZtP0LmuoiyvRDFqBF8aTmnotyb4kRKohnJ7VF+y6hYvmtMpM3TKnpR7EbojBzNPqKuO7nPUz
jGxA7F84O24Vbf128PNSI5vj4istow26aPjn28qPjfRrkV30WLL/dXfYJkfkTqglYnoEXvF/
xZoVxxNeAX58mgy0A1ErVxv8U7TwuP983GHEpLwy3gbiP+9akAJCr8r823DHmQqq5QDELibP
cuXZfOttpfVRkcbMhjeF0M6czc4HoKgHTAnf/18hzdZwGX/WWvRIBHImbUJ+mDbp2ByDTfKf
ErGXSvZ3HxCqBD8yx1SnXhV8IDHaBmV9wwYcN+H2cxOWGZk7g7xJS19+a3UQB3c3sSXQVJBp
6QpCZgysxkZwzuXDzzLZPT9SLZz4K2p7+7BwMbpy9ZxcyAzmiEtpA24UP06jtjFN7WcXAdx/
E5Gmoe9b1EiXWdReHjUGpc6k0LQ0PPXAwqrcGdwYbOLDZ5xsQ5AsEYSFtyTS60D1nHBcdNmW
M0eOUJFdJf/uNe/2EApc3a8TyEkZtVqiYtOVV3qDB9NmU4bVOkDqzl1F7zJwATWbmasSdkM3
6lxDkczBfCrEjH5p5Y8DU+ge4e4LRtknY9oBOJ7EQO0twYJg3k0=
@<:@end@:>@
])

AT_DATA(test_hooks.lua, [
-- this is the "testing" set of lua hooks for monotone
-- it's intended to support self-tests, not for use in
-- production. just defines some of the std hooks.

function get_passphrase(keyid)
	return keyid
end

function non_blocking_rng_ok()
	return true
end

-- Everything alice signs is trusted, nothing mallory signs is
-- trusted.  For certs signed by other people, everything is
-- trusted except for one particular cert...
-- For use of t_trusted.at.
function get_revision_cert_trust(signers, id, name, val)
   for k, v in pairs(signers) do
      if v == "alice@trusted.com" then return true end
      if v == "mallory@evil.com" then return false end
   end
   if (id == "0000000000000000000000000000000000000000"
       and name == "bad-cert" and val == "bad-val")
   then return false end
   return true             
end

function get_manifest_cert_trust(signers, id, name, val)
   return true
end

function get_file_cert_trust(signers, id, name, val)
   return true
end

function accept_testresult_change(old_results, new_results)
   for test,res in pairs(old_results)
   do
      if res == true and new_results@<:@test@:>@ ~= true
      then
	 return false
      end
   end
   return true
end

function persist_phrase_ok()
	return true
end

function get_author(branchname)
	return "tester@test.net"
end

function ignore_file(name)
	if (strfind(name, "test_hooks.lua")) then return true end
	if (strfind(name, "test.db")) then return true end
	return false
end

function merge2(left_path, right_path, merged_path, left, right)
	io.write("running merge2 hook\n") 
	return left
end

if (attr_functions == nil) then
  attr_functions = {}
end
attr_functions[["test_attr"]] =
  function(filename, value)
    io.write(string.format("test_attr:%s:%s\n", filename, value))
  end

])

AT_CHECK(MONOTONE setup ., [], [ignore], [ignore])
AT_CHECK(MONOTONE db init, [], [ignore], [ignore])
AT_CHECK(MONOTONE read <test_keys, [], [ignore], [ignore])
AT_CHECK(rm test_keys)
])

# run as CHECK_SAME_STDOUT(command1, command2)
m4_define([CHECK_SAME_STDOUT], [
AT_CHECK($1, [], [stdout], [ignore])
AT_CHECK(mv stdout expout)
AT_CHECK($2, [], [expout], [ignore])
])

# run as CHECK_DIFFERENT_STDOUT(command1, command2)
m4_define([CHECK_DIFFERENT_STDOUT], [
AT_CHECK($1, [], [stdout], [ignore])
AT_CHECK(mv stdout firstout)
AT_CHECK($2, [], [stdout], [ignore])
AT_CHECK(mv stdout secondout)
AT_CHECK(cmp firstout secondout, [1], [ignore], [ignore])
])

# run as CHECK_SAME_DB_CONTENTS(db1, db2)
m4_define([CHECK_SAME_DB_CONTENTS], [
CHECK_SAME_STDOUT(MONOTONE --db=$1 ls keys, MONOTONE --db=$2 ls keys)

CHECK_SAME_STDOUT(MONOTONE --db=$1 agraph, MONOTONE --db=$2 agraph)
REVS=`MONOTONE --db=$1 complete revision ""`
for R in $REVS; do
  CHECK_SAME_STDOUT(MONOTONE --db=$1 ls certs $R, MONOTONE --db=$2 ls certs $R)
  CHECK_SAME_STDOUT(MONOTONE --db=$1 cat revision $R, MONOTONE --db=$2 cat revision $R)
done

CHECK_SAME_STDOUT(MONOTONE --db=$1 complete manifest "", MONOTONE --db=$2 complete manifest "")
MANIFESTS=`MONOTONE --db=$1 complete manifest ""`
for M in $MANIFESTS; do
  CHECK_SAME_STDOUT(MONOTONE --db=$1 cat manifest $M, MONOTONE --db=$2 cat manifest $M)
done

CHECK_SAME_STDOUT(MONOTONE --db=$1 complete file "", MONOTONE --db=$2 complete file "")
FILES=`MONOTONE --db=$1 complete file ""`
for F in $FILES; do
  CHECK_SAME_STDOUT(MONOTONE --db=$1 cat file $F, MONOTONE --db=$2 cat file $F)
done
])

# run as PROBE_NODE(filename, rsha, fsha)
m4_define([PROBE_NODE], [ 
AT_CHECK(rm -rf MT.old)
AT_CHECK(mv  MT MT.old)
AT_CHECK(rm $1)
AT_CHECK(MONOTONE checkout $2 ., [], [ignore])
AT_CHECK(mv MT.old/options MT)
PROBE_R_SHA=`BASE_REVISION`
PROBE_F_SHA=`SHA1($1)`
AT_CHECK(test $PROBE_R_SHA = $2)
AT_CHECK(test $PROBE_F_SHA = $3)
])

# run as REVERT_TO(rsha)
m4_define([REVERT_TO], [ 
AT_CHECK(rm -rf MT.old)
AT_CHECK(mv  MT MT.old)
AT_CHECK(MONOTONE checkout $1 ., [], [ignore])
AT_CHECK(mv MT.old/options MT)
PROBE_R_SHA=`BASE_REVISION`
AT_CHECK(test $PROBE_R_SHA = $1)
])

# run as ADD_FILE(filename, data)
m4_define([ADD_FILE], [
AT_DATA($1, $2)
AT_CHECK(MONOTONE add $1, [], [ignore], [ignore])
])

# run as SET_FILE(filename, data)
m4_define([SET_FILE], [
AT_DATA($1, $2)
])

# run as COMMIT(branch)
m4_define([COMMIT], [
AT_CHECK(MONOTONE --branch=$1 commit --message blah-blah, [], [ignore],
[ignore])
])

# Some tests want to include data files.
# Usage: NEED_UNB64 will cancel the test (reporting success) if we
# can't decode base64'ed text.
# After calling NEED_UNB64, you can use UNB64(infile, outfile) to
# decode base64'ed text.
m4_define([NEED_UNB64], [
if which mimencode 2>/dev/null; then
  UNB64_COMMAND="mimencode -u"
elif which recode 2>/dev/null; then
  UNB64_COMMAND="recode /Base64"
elif perl -MMIME::Base64 -e 1 2>/dev/null; then
  UNB64_COMMAND="perl -MMIME::Base64 -ne 'print decode_base64(\$_)'"
elif python -c 'import sys;sys.exit(not hasattr("", "decode"))' 2>/dev/null; then
  UNB64_COMMAND="python -c 'import sys;sys.stdout.write(sys.stdin.read().decode("'"'"base64"'"'"))'"
else
  # This is lame!  We should XFAIL the test so the user knows that
  # they're not, you know, actually testing the software.  But
  # Autotest runs XFAIL conditions in a completely different shell, so
  # we can't without duplicating the whole test here.
  exit 77
fi
# Poor man's logging:
AT_CHECK(echo $UNB64_COMMAND, [], [ignore], [ignore])
])
m4_define([UNB64], [AT_CHECK(
if test "$OSTYPE" == "msys"; then
  mimencode -u -o $2 $1
else
  eval $UNB64_COMMAND <$1 >$2
fi
)])

# Usage: NEED_UNGZ will cancel the test (reporting success) if we
# can't decode gzipped text.
# After calling NEED_UNGZ, you can use UNGZ(infile, outfile) to
# decode gzipped text.
m4_define([NEED_UNGZ], [
if which gunzip 2>/dev/null; then
  # This is lame!  We should XFAIL the test so the user knows that
  # they're not, you know, actually testing the software.  But
  # Autotest runs XFAIL conditions in a completely different shell, so
  # we can't without duplicating the whole test here.
  UNGZ_COMMAND="gunzip -c"
fi
# Poor man's logging:
AT_CHECK(echo $UNGZ_COMMAND, [], [ignore], [ignore])
])
m4_define([UNGZ], [AT_CHECK(
eval $UNGZ_COMMAND <$1 >$2
if test "$OSTYPE" == "msys"; then
  dos2unix -q -o $2
fi
)])

# Usage: NEED_UNGZB64 will XFAIL the test if we can't decode base64'ed
# gzipped text.
# After calling NEED_UNGZB64, you can use UNGZB64(infile, outfile) to
# decode base64'ed gzipped text.
m4_define([NEED_UNGZB64], [
NEED_UNB64
NEED_UNGZ
])
m4_define([UNGZB64], [
UNB64($1, $2.gz)
UNGZ($2.gz, $2)
])

# netsync helpers
# NETSYNC_SETUP sets up 2 databases; RUN_NETSYNC netsyncs between
# them, MONOTONE2 operates on the second one.

m4_define([NETSYNC_SETUP], [

AT_CHECK(cp test.db test2.db)
AT_CHECK(cp test.db test3.db)
AT_DATA(netsync.lua, [
function get_netsync_read_permitted(collection, identity)
	return true
end

function get_netsync_write_permitted(collection, identity)
	return true
end
])

])

m4_define([MONOTONE2], MONOTONE --db=test2.db)
m4_define([MONOTONE3], MONOTONE --db=test3.db)

m4_define([NETSYNC_KILL], [
if test "$OSTYPE" == "msys"; then
  ps |awk -- '{p=$NF;a=1;if(p=="COMMAND")next;pp=split(p,ps,"/");if(ps[[pp]]=="monotone")system("kill " $a);}'
  # MinGW has no killall.  The weird a=1 thing is to avoid autotest treating $1 as its own parameter
else
  killall monotone 2>/dev/null
fi
])
m4_define([NETSYNC_KILLHARD], [
if test "$OSTYPE" == "msys"; then
  ps |awk -- '{p=$NF;a=1;if(p=="COMMAND")next;pp=split(p,ps,"/");if(ps[[pp]]=="monotone")system("kill -KILL " $a);}'
else
  killall -KILL monotone 2>/dev/null
fi
])

# run as NETSYNC_SERVE_N_START(2|3, collection name)
# note that NETSYNC_SERVE_START is _not_ a special case of this macro.
m4_define([NETSYNC_SERVE_N_START], [
NETSYNC_KILLHARD
MONOTONE --db=test$1.db --rcfile=netsync.lua serve localhost:5555 $2 &
sleep 4
])
# run as NETSYNC_SERVE_START(collection name)
m4_define([NETSYNC_SERVE_START], [
NETSYNC_KILLHARD
MONOTONE --rcfile=netsync.lua serve localhost:5555 $1 &
sleep 4
])
# run as NETSYNC_SERVE_STOP
m4_define([NETSYNC_SERVE_STOP], [
NETSYNC_KILL
sleep 1
NETSYNC_KILLHARD
])
# run as NETSYNC_CLIENT_N_RUN(2|3, push|pull|sync, collection name[, expected result])
# first argument chooses whether to use the 2nd or 3rd database
m4_define([NETSYNC_CLIENT_N_RUN], [
AT_CHECK(MONOTONE --db=test$1.db --rcfile=netsync.lua $2 localhost:5555 $3, [$4], [ignore], [ignore])
])
# run as NETSYNC_CLIENT_RUN(push|pull|sync, collection name[, expected result])
m4_define([NETSYNC_CLIENT_RUN], [
NETSYNC_CLIENT_N_RUN(2, $1, $2, $3)
])
# run as RUN_NETSYNC(push|pull|sync, collection name)
# It is the second database that is always the client; take this into
# account when choosing push|pull|sync.
m4_define([RUN_NETSYNC], [
NETSYNC_SERVE_START($2)
NETSYNC_CLIENT_RUN($1, $2, 0)
NETSYNC_SERVE_STOP
])



# include all the sub-tests we're going to use

m4_include(tests/t_null.at)
m4_include(tests/t_scan.at)
m4_include(tests/t_import.at)
m4_include(tests/t_genkey.at)
m4_include(tests/t_unidiff.at)
m4_include(tests/t_persist_phrase.at)
m4_include(tests/t_versions.at)
m4_include(tests/t_fork.at)
m4_include(tests/t_update.at)
m4_include(tests/t_merge.at)
m4_include(tests/t_merge_add.at)
m4_include(tests/t_related_merge2_data.at)
m4_include(tests/t_merge2_add.at)
m4_include(tests/t_merge2_data.at)
m4_include(tests/t_unidiff2.at)
m4_include(tests/t_cwork.at)
m4_include(tests/t_revert.at)
m4_include(tests/t_add.at)
m4_include(tests/t_drop.at)
m4_include(tests/t_drop_missing.at)
m4_include(tests/t_cross.at)
m4_include(tests/t_rename.at)
m4_include(tests/t_renamed.at)
m4_include(tests/t_erename.at)
m4_include(tests/t_cvsimport.at)
m4_include(tests/t_i18n_file.at)
m4_include(tests/t_fmerge.at)
m4_include(tests/t_netsync.at)
m4_include(tests/t_netsync_single.at)
m4_include(tests/t_netsync_pubkey.at)
m4_include(tests/t_netsync_repeated.at)
m4_include(tests/t_netsync_unrelated.at)
m4_include(tests/t_disapprove.at)
m4_include(tests/t_testresult.at)
m4_include(tests/t_singlecvs.at)
m4_include(tests/t_ls_missing.at)
m4_include(tests/t_attributes.at)
m4_include(tests/t_single_char_filenames.at)
m4_include(tests/t_restrictions.at)
m4_include(tests/t_subdirs.at)
m4_include(tests/t_movepatch.at)
m4_include(tests/t_movedel.at)
m4_include(tests/t_remerge.at)
m4_include(tests/t_update_missing.at)
m4_include(tests/t_chkeypass.at)
m4_include(tests/t_diff_added_file.at)
m4_include(tests/t_update_to_revision.at)
m4_include(tests/t_heads.at)
m4_include(tests/t_heads_discontinuous_branch.at)
m4_include(tests/t_merge_1.at)
m4_include(tests/t_merge_2.at)
m4_include(tests/t_tags.at)
m4_include(tests/t_add_dot.at)
m4_include(tests/t_cleanup_empty_dir.at)
m4_include(tests/t_merge_add_del.at)
m4_include(tests/t_add_edge.at)
m4_include(tests/t_patch_drop_add.at)
m4_include(tests/t_add_drop_add.at)
m4_include(tests/t_merge2_add_drop_add.at)
m4_include(tests/t_add_patch_drop_add.at)
m4_include(tests/t_patch_vs_drop_add.at)
m4_include(tests/t_explicit_merge.at)
m4_include(tests/t_ambig_update.at)
m4_include(tests/t_checkout_dir.at)
m4_include(tests/t_checkout_options.at)
m4_include(tests/t_trusted.at)
m4_include(tests/t_attr.at)
m4_include(tests/t_rcfile_required.at)
m4_include(tests/t_persistent_server_revision.at)
m4_include(tests/t_persistent_server_keys.at)
m4_include(tests/t_fmerge_normalize.at)
m4_include(tests/t_delete_dir.at)
m4_include(tests/t_migrate_schema.at)
m4_include(tests/t_dump_load.at)
m4_include(tests/t_no_change_deltas.at)
m4_include(tests/t_drop_rename_patch.at)
m4_include(tests/t_cmdline_options.at)
m4_include(tests/t_log_nonexistent.at)
m4_include(tests/t_crlf.at)
m4_include(tests/t_netsync_diffbranch.at)
m4_include(tests/t_netsync_nocerts.at)
m4_include(tests/t_check_same_db_contents.at)
m4_include(tests/t_merge_ancestor.at)
m4_include(tests/t_propagate_desc.at)
m4_include(tests/t_propagate_anc.at)
m4_include(tests/t_status_missing.at)
m4_include(tests/t_persistent_server_keys_2.at)
m4_include(tests/t_update_1.at)
m4_include(tests/t_vcheck.at)
m4_include(tests/t_db_with_dots.at)
m4_include(tests/t_subdir_add.at)
m4_include(tests/t_subdir_drop.at)
m4_include(tests/t_subdir_revert.at)
m4_include(tests/t_subdir_rename.at)
m4_include(tests/t_subdir_attr.at)
m4_include(tests/t_lca_1.at)
m4_include(tests/t_update_2.at)
m4_include(tests/t_rename_dir_cross_level.at)
m4_include(tests/t_rename_added_in_rename.at)
m4_include(tests/t_rename_conflict.at)
m4_include(tests/t_rename_dir_patch.at)
m4_include(tests/t_delete_dir_patch.at)
m4_include(tests/t_revert_dirs.at)
m4_include(tests/t_revert_rename.at)
m4_include(tests/t_revert_unchanged.at)
m4_include(tests/t_cdiff.at)
m4_include(tests/t_no_rename_overwrite.at)
m4_include(tests/t_checkout_noop_on_fail.at)
m4_include(tests/t_monotone_agent.at)
m4_include(tests/t_approval_semantics.at)
m4_include(tests/t_rebuild.at)
m4_include(tests/t_lua_privkey.at)
m4_include(tests/t_i18n_changelog.at)
m4_include(tests/t_restrictions_warn_on_unknown.at)
m4_include(tests/t_need_mt_revision.at)
m4_include(tests/t_update_null_revision.at)
m4_include(tests/t_branch_checkout.at)
m4_include(tests/t_load_into_existing.at)
m4_include(tests/t_automate_version.at)
m4_include(tests/t_automate_heads.at)
m4_include(tests/t_merge_normalization_edge_case.at)
m4_include(tests/t_undo_update.at)
m4_include(tests/t_change_empty_file.at)
m4_include(tests/t_largish_file.at)
m4_include(tests/t_add_intermediate_MT_path.at)
m4_include(tests/t_merge_3.at)
m4_include(tests/t_merge_4.at)
m4_include(tests/t_db_missing.at)
m4_include(tests/t_database_check.at)
m4_include(tests/t_add_owndb.at)
m4_include(tests/t_can_execute.at)
m4_include(tests/t_diff_binary.at)
m4_include(tests/t_command_completion.at)
m4_include(tests/t_merge_rename_file_and_rename_dir.at)
m4_include(tests/t_diff_restrict.at)
m4_include(tests/t_cat_file_by_name.at)
m4_include(tests/t_epoch.at)
m4_include(tests/t_epoch_server.at)
m4_include(tests/t_epoch_unidirectional.at)
m4_include(tests/t_vars.at)
m4_include(tests/t_netsync_defaults.at)
m4_include(tests/t_netsync_set_defaults.at)
m4_include(tests/t_netsync_absorbs.at)
m4_include(tests/t_netsync_checks_server_key.at)
m4_include(tests/t_merge_5.at)
m4_include(tests/t_empty_id_completion.at)
m4_include(tests/t_empty_path.at)
m4_include(tests/t_empty_env.at)
m4_include(tests/t_short_opts.at)
m4_include(tests/t_netsync_sigpipe.at)
m4_include(tests/t_setup_creates_log.at)
m4_include(tests/t_checkout_creates_log.at)
m4_include(tests/t_commit_log_1.at)
m4_include(tests/t_commit_log_2.at)
m4_include(tests/t_delkey_1.at)
m4_include(tests/t_delkey_2.at)
m4_include(tests/t_rename_attr.at)
m4_include(tests/t_automate_descendents.at)
m4_include(tests/t_automate_erase_ancestors.at)
m4_include(tests/t_automate_toposort.at)
m4_include(tests/t_diff_first_rev.at)
m4_include(tests/t_automate_ancestry_difference.at)
m4_include(tests/t_automate_leaves.at)
m4_include(tests/t_log_depth.at)
